{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"modsim","text":"<p>A Simple Modbus TCP Device Simulator used for modpoll tool</p>"},{"location":"modules/","title":"Modules","text":"<p>Pymodbus asynchronous Server Example. An example of a multi threaded asynchronous server. usage: server_async.py -h                        [--framer {ascii,binary,rtu,socket,tls}]                        [--log {critical,error,warning,info,debug}]                        --port PORT                        [--slaves SLAVES] Command line options for examples options:   -h, --help            show this help message and exit   --comm {tcp,udp,serial,tls}                         \"serial\", \"tcp\", \"udp\" or \"tls\"   --framer {ascii,binary,rtu,socket,tls}                         \"ascii\", \"binary\", \"rtu\", \"socket\" or \"tls\"   --log {critical,error,warning,info,debug}                         \"critical\", \"error\", \"warning\", \"info\" or \"debug\"   --port PORT           the port to use   --store {sequential,sparse,factory,none}                         \"sequential\", \"sparse\", \"factory\" or \"none\"   --slaves SLAVES       number of slaves to respond to The corresponding client can be started as:     python3 client_sync.py</p>"},{"location":"modules/#modsim.main.run_async_server","title":"<code>run_async_server(args)</code>  <code>async</code>","text":"<p>Run server.</p> Source code in <code>modsim/main.py</code> <pre><code>async def run_async_server(args: Any) -&gt; Any:\n    \"\"\"Run server.\"\"\"\n    txt = f\"Start ASYNC server, listening on {args.port} - {args.comm}\"\n    _logger.info(txt)\n    if args.comm == \"tcp\":\n        address = (\"\", args.port) if args.port else None\n        server = await StartAsyncTcpServer(\n            context=args.context,  # Data storage\n            identity=args.identity,  # server identify\n            # TBD host=\n            # TBD port=\n            address=address,  # listen address\n            # custom_functions=[],  # allow custom handling\n            framer=args.framer,  # The framer strategy to use\n            # ignore_missing_slaves=True,  # ignore request to a missing slave\n            # broadcast_enable=False,  # treat slave_id 0 as broadcast address,\n            # timeout=1,  # waiting time for request to complete\n            # TBD strict=True,  # use strict timing, t1.5 for Modbus RTU\n        )\n    elif args.comm == \"udp\":\n        address = (\"127.0.0.1\", args.port) if args.port else None\n        server = await StartAsyncUdpServer(\n            context=args.context,  # Data storage\n            identity=args.identity,  # server identify\n            address=address,  # listen address\n            # custom_functions=[],  # allow custom handling\n            framer=args.framer,  # The framer strategy to use\n            # handler=None,  # handler for each session\n            # ignore_missing_slaves=True,  # ignore request to a missing slave\n            # broadcast_enable=False,  # treat unit_id 0 as broadcast address,\n            # timeout=1,  # waiting time for request to complete\n            # TBD strict=True,  # use strict timing, t1.5 for Modbus RTU\n            # defer_start=False,  # Only define server do not activate\n        )\n    elif args.comm == \"serial\":\n        # socat -d -d PTY,link=/tmp/ptyp0,raw,echo=0,ispeed=9600\n        #             PTY,link=/tmp/ttyp0,raw,echo=0,ospeed=9600\n        server = await StartAsyncSerialServer(\n            context=args.context,  # Data storage\n            identity=args.identity,  # server identify\n            # timeout=1,  # waiting time for request to complete\n            port=args.port,  # serial port\n            # custom_functions=[],  # allow custom handling\n            framer=args.framer,  # The framer strategy to use\n            # handler=None,  # handler for each session\n            # stopbits=1,  # The number of stop bits to use\n            # bytesize=8,  # The bytesize of the serial messages\n            # parity=\"N\",  # Which kind of parity to use\n            # baudrate=9600,  # The baud rate to use for the serial device\n            # handle_local_echo=False,  # Handle local echo of the USB-to-RS485 adaptor\n            # ignore_missing_slaves=True,  # ignore request to a missing slave\n            # broadcast_enable=False,  # treat unit_id 0 as broadcast address,\n            # strict=True,  # use strict timing, t1.5 for Modbus RTU\n            # defer_start=False,  # Only define server do not activate\n        )\n    elif args.comm == \"tls\":\n        address = (\"\", args.port) if args.port else None\n        cwd = os.getcwd().split(\"/\")[-1]\n        if cwd == \"examples\":\n            path = \".\"\n        elif cwd == \"test\":\n            path = \"../examples\"\n        else:\n            path = \"examples\"\n        server = await StartAsyncTlsServer(\n            context=args.context,  # Data storage\n            host=\"localhost\",  # define tcp address where to connect to.\n            # port=port,  # on which port\n            identity=args.identity,  # server identify\n            # custom_functions=[],  # allow custom handling\n            address=address,  # listen address\n            framer=args.framer,  # The framer strategy to use\n            # handler=None,  # handler for each session\n            allow_reuse_address=True,  # allow the reuse of an address\n            # The cert file path for TLS (used if sslctx is None)\n            certfile=f\"{path}/certificates/pymodbus.crt\",\n            # sslctx=sslctx,  # The SSLContext to use for TLS (default None and auto create)\n            # The key file path for TLS (used if sslctx is None)\n            keyfile=f\"{path}/certificates/pymodbus.key\",\n            # password=\"none\",  # The password for for decrypting the private key file\n            # reqclicert=False,  # Force the sever request client\"s certificate\n            # ignore_missing_slaves=True,  # ignore request to a missing slave\n            # broadcast_enable=False,  # treat unit_id 0 as broadcast address,\n            # timeout=1,  # waiting time for request to complete\n            # TBD strict=True,  # use strict timing, t1.5 for Modbus RTU\n            defer_start=False,  # Only define server do not activate\n        )\n    return server\n</code></pre>"},{"location":"modules/#modsim.main.setup_server","title":"<code>setup_server(args)</code>","text":"<p>Run server setup.</p> Source code in <code>modsim/main.py</code> <pre><code>def setup_server(args: Any) -&gt; Any:\n    \"\"\"Run server setup.\"\"\"\n    # The datastores only respond to the addresses that are initialized\n    # If you initialize a DataBlock to addresses of 0x00 to 0xFF, a request to\n    # 0x100 will respond with an invalid address exception.\n    # This is because many devices exhibit this kind of behavior (but not all)\n    if not args.context:\n        _logger.info(\"Create datastore\")\n        # ----------------------------------------------------------------------- #\n        # build your payload\n        # ----------------------------------------------------------------------- #\n        co_builder = BinaryPayloadBuilder(byteorder=Endian.BIG, wordorder=Endian.BIG)\n        # address=0, bytes=3\n        for i in range(3):\n            # The bits within each byte are big-endian\n            # The coils status (from the first position) = [1,0,1,0,0,0,0,1]\n            co_builder.add_bits([True, False, False, False, False, True, False, True])\n\n        hr_builder = BinaryPayloadBuilder(byteorder=Endian.BIG, wordorder=Endian.BIG)\n        # address=0, bytes=8\n        hr_builder.add_16bit_uint(1)\n        hr_builder.add_16bit_uint(2)\n        hr_builder.add_16bit_uint(3)\n        hr_builder.add_16bit_uint(4)\n        # address=8, bytes=8\n        hr_builder.add_16bit_int(-1)\n        hr_builder.add_16bit_int(-2)\n        hr_builder.add_16bit_int(-3)\n        hr_builder.add_16bit_int(-4)\n        # address=16, bytes=8\n        hr_builder.add_32bit_uint(12345678)\n        hr_builder.add_32bit_uint(12345678)\n        # address=24, bytes=8\n        hr_builder.add_32bit_int(-12345678)\n        hr_builder.add_32bit_int(-12345678)\n        # address=32, bytes=8\n        hr_builder.add_32bit_float(12.34)\n        hr_builder.add_32bit_float(-12.34)\n        # address=40, bytes=8\n        hr_builder.add_64bit_uint(12345678900)\n        # address=48, bytes=8\n        hr_builder.add_64bit_int(-12345678900)\n        # address=56, bytes=16\n        hr_builder.add_64bit_float(123.45)\n        hr_builder.add_64bit_float(-123.45)\n        # address=72, bytes=?\n        hr_builder.add_string(\"this is a string\")\n\n        # ----------------------------------------------------------------------- #\n        # use that payload in the data store\n        # ----------------------------------------------------------------------- #\n        # Here we use the same reference block for each underlying store.\n        # ----------------------------------------------------------------------- #\n        co_values = co_builder.to_coils()\n        hr_values = hr_builder.to_registers()\n        store = ModbusSlaveContext(\n            co=ModbusSequentialDataBlock(0, co_values),\n            di=ModbusSequentialDataBlock(10000, co_values),\n            ir=ModbusSequentialDataBlock(30000, hr_values),\n            hr=ModbusSequentialDataBlock(40000, hr_values),\n            zero_mode=True,\n        )\n        args.context = ModbusServerContext(slaves=store, single=True)\n\n    # ----------------------------------------------------------------------- #\n    # initialize the server information\n    # ----------------------------------------------------------------------- #\n    # If you don't set this or any fields, they are defaulted to empty strings.\n    # ----------------------------------------------------------------------- #\n    args.identity = ModbusDeviceIdentification(\n        info_name={\n            \"VendorName\": \"Pymodbus\",\n            \"ProductCode\": \"PM\",\n            \"VendorUrl\": \"https://github.com/riptideio/pymodbus/\",\n            \"ProductName\": \"Pymodbus Server\",\n            \"ModelName\": \"Pymodbus Server\",\n        }\n    )\n    return args\n</code></pre>"}]}